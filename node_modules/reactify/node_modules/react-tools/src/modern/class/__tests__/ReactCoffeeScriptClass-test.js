
/*
Copyright 2015, Facebook, Inc.
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree. An additional grant
of patent rights can be found in the PATENTS file in the same directory.
 */

(function() {
  var React,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  React = null;

  describe('ReactCoffeeScriptClass', function() {
    var Inner, attachedListener, container, div, renderedName, span, test;
    div = null;
    span = null;
    container = null;
    Inner = null;
    attachedListener = null;
    renderedName = null;
    beforeEach(function() {
      var InnerComponent;
      React = require('React');
      container = document.createElement('div');
      attachedListener = null;
      renderedName = null;
      div = React.createFactory('div');
      span = React.createFactory('span');
      InnerComponent = (function(_super) {
        __extends(InnerComponent, _super);

        function InnerComponent() {
          return InnerComponent.__super__.constructor.apply(this, arguments);
        }

        InnerComponent.prototype.getName = function() {
          return this.props.name;
        };

        InnerComponent.prototype.render = function() {
          attachedListener = this.props.onClick;
          renderedName = this.props.name;
          return div({
            className: this.props.name
          });
        };

        return InnerComponent;

      })(React.Component);
      return Inner = React.createFactory(InnerComponent);
    });
    test = function(element, expectedTag, expectedClassName) {
      var instance;
      instance = React.render(element, container);
      expect(container.firstChild).not.toBeNull();
      expect(container.firstChild.tagName).toBe(expectedTag);
      expect(container.firstChild.className).toBe(expectedClassName);
      return instance;
    };
    it('preserves the name of the class for use in error messages', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo() {
          return Foo.__super__.constructor.apply(this, arguments);
        }

        return Foo;

      })(React.Component);
      return expect(Foo.name).toBe('Foo');
    });
    it('throws if no render function is defined', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo() {
          return Foo.__super__.constructor.apply(this, arguments);
        }

        return Foo;

      })(React.Component);
      return expect(function() {
        return React.render(React.createElement(Foo), container);
      }).toThrow();
    });
    it('renders a simple stateless component with prop', function() {
      var Foo;
      Foo = (function() {
        function Foo() {}

        Foo.prototype.render = function() {
          return Inner({
            name: this.props.bar
          });
        };

        return Foo;

      })();
      test(React.createElement(Foo, {
        bar: 'foo'
      }), 'DIV', 'foo');
      return test(React.createElement(Foo, {
        bar: 'bar'
      }), 'DIV', 'bar');
    });
    it('renders based on state using initial values in this.props', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          Foo.__super__.constructor.call(this, props);
          this.state = {
            bar: this.props.initialValue
          };
        }

        Foo.prototype.render = function() {
          return span({
            className: this.state.bar
          });
        };

        return Foo;

      })(React.Component);
      return test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'SPAN', 'foo');
    });
    it('renders based on state using props in the constructor', function() {
      var Foo, instance;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          this.state = {
            bar: props.initialValue
          };
        }

        Foo.prototype.changeState = function() {
          return this.setState({
            bar: 'bar'
          });
        };

        Foo.prototype.render = function() {
          if (this.state.bar === 'foo') {
            return div({
              className: 'foo'
            });
          }
          return span({
            className: this.state.bar
          });
        };

        return Foo;

      })(React.Component);
      instance = test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'DIV', 'foo');
      instance.changeState();
      return test(React.createElement(Foo), 'SPAN', 'bar');
    });
    it('renders based on context in the constructor', function() {
      var Foo, Outer;
      Foo = (function(_super) {
        __extends(Foo, _super);

        Foo.contextTypes = {
          tag: React.PropTypes.string,
          className: React.PropTypes.string
        };

        function Foo(props, context) {
          Foo.__super__.constructor.call(this, props, context);
          this.state = {
            tag: context.tag,
            className: this.context.className
          };
        }

        Foo.prototype.render = function() {
          var Tag;
          Tag = this.state.tag;
          return React.createElement(Tag, {
            className: this.state.className
          });
        };

        return Foo;

      })(React.Component);
      Outer = (function(_super) {
        __extends(Outer, _super);

        function Outer() {
          return Outer.__super__.constructor.apply(this, arguments);
        }

        Outer.childContextTypes = {
          tag: React.PropTypes.string,
          className: React.PropTypes.string
        };

        Outer.prototype.getChildContext = function() {
          return {
            tag: 'span',
            className: 'foo'
          };
        };

        Outer.prototype.render = function() {
          return React.createElement(Foo);
        };

        return Outer;

      })(React.Component);
      return test(React.createElement(Outer), 'SPAN', 'foo');
    });
    it('renders only once when setting state in componentWillMount', function() {
      var Foo, renderCount;
      renderCount = 0;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          this.state = {
            bar: props.initialValue
          };
        }

        Foo.prototype.componentWillMount = function() {
          return this.setState({
            bar: 'bar'
          });
        };

        Foo.prototype.render = function() {
          renderCount++;
          return span({
            className: this.state.bar
          });
        };

        return Foo;

      })(React.Component);
      test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'SPAN', 'bar');
      return expect(renderCount).toBe(1);
    });
    it('should throw with non-object in the initial state property', function() {
      return [['an array'], 'a string', 1234].forEach(function(state) {
        var Foo;
        Foo = (function() {
          function Foo() {
            this.state = state;
          }

          Foo.prototype.render = function() {
            return span();
          };

          return Foo;

        })();
        return expect(function() {
          return test(React.createElement(Foo), 'span', '');
        }).toThrow('Invariant Violation: Foo.state: must be set to an object or null');
      });
    });
    it('should render with null in the initial state property', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo() {
          this.state = null;
        }

        Foo.prototype.render = function() {
          return span();
        };

        return Foo;

      })(React.Component);
      return test(React.createElement(Foo), 'SPAN', '');
    });
    it('setState through an event handler', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          this.handleClick = __bind(this.handleClick, this);
          this.state = {
            bar: props.initialValue
          };
        }

        Foo.prototype.handleClick = function() {
          return this.setState({
            bar: 'bar'
          });
        };

        Foo.prototype.render = function() {
          return Inner({
            name: this.state.bar,
            onClick: this.handleClick
          });
        };

        return Foo;

      })(React.Component);
      test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'DIV', 'foo');
      attachedListener();
      return expect(renderedName).toBe('bar');
    });
    it('should not implicitly bind event handlers', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          this.state = {
            bar: props.initialValue
          };
        }

        Foo.prototype.handleClick = function() {
          return this.setState({
            bar: 'bar'
          });
        };

        Foo.prototype.render = function() {
          return Inner({
            name: this.state.bar,
            onClick: this.handleClick
          });
        };

        return Foo;

      })(React.Component);
      test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'DIV', 'foo');
      return expect(attachedListener).toThrow();
    });
    it('renders using forceUpdate even when there is no state', function() {
      var Foo;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo(props) {
          this.handleClick = __bind(this.handleClick, this);
          this.mutativeValue = props.initialValue;
        }

        Foo.prototype.handleClick = function() {
          this.mutativeValue = 'bar';
          return this.forceUpdate();
        };

        Foo.prototype.render = function() {
          return Inner({
            name: this.mutativeValue,
            onClick: this.handleClick
          });
        };

        return Foo;

      })(React.Component);
      test(React.createElement(Foo, {
        initialValue: 'foo'
      }), 'DIV', 'foo');
      attachedListener();
      return expect(renderedName).toBe('bar');
    });
    it('will call all the normal life cycle methods', function() {
      var Foo, lifeCycles;
      lifeCycles = [];
      Foo = (function() {
        function Foo() {
          this.state = {};
        }

        Foo.prototype.componentWillMount = function() {
          return lifeCycles.push('will-mount');
        };

        Foo.prototype.componentDidMount = function() {
          return lifeCycles.push('did-mount');
        };

        Foo.prototype.componentWillReceiveProps = function(nextProps) {
          return lifeCycles.push('receive-props', nextProps);
        };

        Foo.prototype.shouldComponentUpdate = function(nextProps, nextState) {
          lifeCycles.push('should-update', nextProps, nextState);
          return true;
        };

        Foo.prototype.componentWillUpdate = function(nextProps, nextState) {
          return lifeCycles.push('will-update', nextProps, nextState);
        };

        Foo.prototype.componentDidUpdate = function(prevProps, prevState) {
          return lifeCycles.push('did-update', prevProps, prevState);
        };

        Foo.prototype.componentWillUnmount = function() {
          return lifeCycles.push('will-unmount');
        };

        Foo.prototype.render = function() {
          return span({
            className: this.props.value
          });
        };

        return Foo;

      })();
      test(React.createElement(Foo, {
        value: 'foo'
      }), 'SPAN', 'foo');
      expect(lifeCycles).toEqual(['will-mount', 'did-mount']);
      lifeCycles = [];
      test(React.createElement(Foo, {
        value: 'bar'
      }), 'SPAN', 'bar');
      expect(lifeCycles).toEqual([
        'receive-props', {
          value: 'bar'
        }, 'should-update', {
          value: 'bar'
        }, {}, 'will-update', {
          value: 'bar'
        }, {}, 'did-update', {
          value: 'foo'
        }, {}
      ]);
      lifeCycles = [];
      React.unmountComponentAtNode(container);
      return expect(lifeCycles).toEqual(['will-unmount']);
    });
    it('warns when classic properties are defined on the instance, but does not invoke them.', function() {
      var Foo, getDefaultPropsWasCalled, getInitialStateWasCalled;
      spyOn(console, 'warn');
      getInitialStateWasCalled = false;
      getDefaultPropsWasCalled = false;
      Foo = (function(_super) {
        __extends(Foo, _super);

        function Foo() {
          this.contextTypes = {};
          this.propTypes = {};
        }

        Foo.prototype.getInitialState = function() {
          getInitialStateWasCalled = true;
          return {};
        };

        Foo.prototype.getDefaultProps = function() {
          getDefaultPropsWasCalled = true;
          return {};
        };

        Foo.prototype.render = function() {
          return span({
            className: 'foo'
          });
        };

        return Foo;

      })(React.Component);
      test(React.createElement(Foo), 'SPAN', 'foo');
      expect(getInitialStateWasCalled).toBe(false);
      expect(getDefaultPropsWasCalled).toBe(false);
      expect(console.warn.calls.length).toBe(4);
      expect(console.warn.calls[0].args[0]).toContain('getInitialState was defined on Foo, a plain JavaScript class.');
      expect(console.warn.calls[1].args[0]).toContain('getDefaultProps was defined on Foo, a plain JavaScript class.');
      expect(console.warn.calls[2].args[0]).toContain('propTypes was defined as an instance property on Foo.');
      return expect(console.warn.calls[3].args[0]).toContain('contextTypes was defined as an instance property on Foo.');
    });
    it('should warn when mispelling shouldComponentUpdate', function() {
      var NamedComponent;
      spyOn(console, 'warn');
      NamedComponent = (function() {
        function NamedComponent() {}

        NamedComponent.prototype.componentShouldUpdate = function() {
          return false;
        };

        NamedComponent.prototype.render = function() {
          return span({
            className: 'foo'
          });
        };

        return NamedComponent;

      })();
      test(React.createElement(NamedComponent), 'SPAN', 'foo');
      expect(console.warn.calls.length).toBe(1);
      return expect(console.warn.calls[0].args[0]).toBe('Warning: NamedComponent has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.');
    });
    it('should throw AND warn when trying to access classic APIs', function() {
      var instance;
      spyOn(console, 'warn');
      instance = test(Inner({
        name: 'foo'
      }), 'DIV', 'foo');
      expect(function() {
        return instance.getDOMNode();
      }).toThrow();
      expect(function() {
        return instance.replaceState({});
      }).toThrow();
      expect(function() {
        return instance.isMounted();
      }).toThrow();
      expect(function() {
        return instance.setProps({
          name: 'bar'
        });
      }).toThrow();
      expect(function() {
        return instance.replaceProps({
          name: 'bar'
        });
      }).toThrow();
      expect(console.warn.calls.length).toBe(5);
      expect(console.warn.calls[0].args[0]).toContain('getDOMNode(...) is deprecated in plain JavaScript React classes');
      expect(console.warn.calls[1].args[0]).toContain('replaceState(...) is deprecated in plain JavaScript React classes');
      expect(console.warn.calls[2].args[0]).toContain('isMounted(...) is deprecated in plain JavaScript React classes');
      expect(console.warn.calls[3].args[0]).toContain('setProps(...) is deprecated in plain JavaScript React classes');
      return expect(console.warn.calls[4].args[0]).toContain('replaceProps(...) is deprecated in plain JavaScript React classes');
    });
    it('supports this.context passed via getChildContext', function() {
      var Bar, Foo;
      Bar = (function() {
        function Bar() {}

        Bar.contextTypes = {
          bar: React.PropTypes.string
        };

        Bar.prototype.render = function() {
          return div({
            className: this.context.bar
          });
        };

        return Bar;

      })();
      Foo = (function() {
        function Foo() {}

        Foo.childContextTypes = {
          bar: React.PropTypes.string
        };

        Foo.prototype.getChildContext = function() {
          return {
            bar: 'bar-through-context'
          };
        };

        Foo.prototype.render = function() {
          return React.createElement(Bar);
        };

        return Foo;

      })();
      return test(React.createElement(Foo), 'DIV', 'bar-through-context');
    });
    it('supports classic refs', function() {
      var Foo, instance;
      Foo = (function() {
        function Foo() {}

        Foo.prototype.render = function() {
          return Inner({
            name: 'foo',
            ref: 'inner'
          });
        };

        return Foo;

      })();
      instance = test(React.createElement(Foo), 'DIV', 'foo');
      return expect(instance.refs.inner.getName()).toBe('foo');
    });
    return it('supports drilling through to the DOM using findDOMNode', function() {
      var instance, node;
      instance = test(Inner({
        name: 'foo'
      }), 'DIV', 'foo');
      node = React.findDOMNode(instance);
      return expect(node).toBe(container.firstChild);
    });
  });

}).call(this);
